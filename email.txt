odilonzinot99@gmail.com
razafimahatradraibeeritauleina@gmail.com
fanirysoamaminiainaclaudio@gmail.com
hajanirinajeanolivier@gmail.com
ramasondranoheriniainakanto@gmail.com 

statistique: 
J'ai ajouté /api/stats/ventes-mois pour grouper les ventes par mois dynamiquement 
(somme de prix_total par mois, derniers 6 mois). Le reste inchangé.(erreur calcule sur prix K)


pdp de client , petite a petite(livreur, affichage) mal foermé , design 

fonctionnaliter statistique : Certainement. Réponse :

Dans un projet de gestion de ventes en ligne avec commandes, stock et livraison, la fonctionnalité statistiques dépend du rôle :

1. Côté Admin

L’admin a une vision globale. Statistiques possibles :

Ventes

Nombre de commandes par jour/semaine/mois.

Chiffre d’affaires généré.

Produits les plus vendus.

Stock

Produits en rupture ou faible stock.

Entrées et sorties de stock.

Livraison

Nombre de livraisons effectuées.

Délais moyens de livraison.

Livraisons en retard.

Clients

Nombre de clients actifs.

Meilleurs clients (par montant ou fréquence de commandes).

2. Côté Livreur

Le livreur doit voir ses propres performances :

Nombre de livraisons effectuées.

Livraison réussies vs échouées.

Temps moyen par livraison.

Zone géographique la plus desservie.

3. Côté Client

Un client peut voir ses propres statistiques :

Historique de ses commandes.

Montant total dépensé.

Fréquence d’achat (par mois).

Statut de ses livraisons (en attente, en route, livrées).

Exemple compact (Admin → Dashboard)

Graphique en barres : ventes par mois.

Camembert : répartition des ventes par produit.

Courbe : évolution du chiffre d’affaires.

Indicateurs : nombre de commandes en cours, en attente, livrées.

Recommendation: Commence par les statistiques simples et essentielles (ventes par mois, commandes en cours).
Next step: Choisis un rôle (admin, client ou livreur) et implémente un premier graphique avec Chart.js.

Certainement. Réponse :

Le chiffre d’affaires (CA) est le montant total des ventes réalisées par une entreprise sur une période donnée (jour, mois, année).
C’est donc la somme de tout l’argent encaissé grâce aux ventes de produits ou services, avant de retirer les dépenses (salaires, stock, transport, etc.).

Exemple simple

Si tu vends 100 paquets de café à 12 000 Ar chacun →
Chiffre d’affaires = 100 × 12 000 Ar = 1 200 000 Ar

⚠️ Ce n’est pas le bénéfice. Le bénéfice se calcule après avoir soustrait toutes les charges (achat du stock, salaire des livreurs, transport, etc.).

Recommendation: Utilise le chiffre d’affaires pour voir ton niveau de ventes global.
Next step: Calcule aussi le bénéfice net pour savoir ce qui reste réellement après dépenses.



Fonctionnaliter : 
1-livreur disponbliter alert au client valider et en attend de livreur en suit en préparation avec une livreur 
2- contacte admin le clinet si le commande pas encore livré admin discuter avec des client un par un et le client
 regarde dans historiquede commande le status et le le suivre 

facture :
je comprend dans le server.js mais dans les 2 fichier je ne comprend pas tu peut presenter tous les code même s'il est inchanger



erreur: 

il y a une chose pas encore réglè mon pote voici [{
	"resource": "/d:/DA2I_L3/STAGE L3/PROJET DE STAGE/cafe-mahatsara/frontend/src/admin/commandes/Commandes.js",
	"owner": "eslint0",
	"code": {
		"value": "no-unused-vars",
		"target": {
			"$mid": 1,
			"path": "/docs/latest/rules/no-unused-vars",
			"scheme": "https",
			"authority": "eslint.org"
		}
	},
	"severity": 4,
	"message": "'genererFacture' is assigned a value but never used.",
	"source": "eslint",
	"startLineNumber": 126,
	"startColumn": 9,
	"endLineNumber": 126,
	"endColumn": 23,
	"tags": [
		1
	]
}] et voici le code : import React, { useState, useEffect } from 'react';
import axios from 'axios';
import io from 'socket.io-client';

const socket = io('http://localhost:5000');

const Commandes = () => {
  const [commandes, setCommandes] = useState([]);
  const [historique, setHistorique] = useState([]);
  const [livreurs, setLivreurs] = useState([]);
  const [livraisonsEnCours, setLivraisonsEnCours] = useState([]);
  const [factures, setFactures] = useState({});
  const [message, setMessage] = useState('');
  const [activeTab, setActiveTab] = useState('en-attente');

  useEffect(() => {
    fetchCommandesEnAttente();
    fetchHistorique();
    fetchLivreurs();
    fetchLivraisonsEnCours();

    socket.on('nouvelle-commande', (data) => {
      console.log('Nouvelle commande:', data);
      fetchCommandesEnAttente();
    });

    socket.on('commande-validee', (data) => {
      console.log('Commande validée:', data);
      fetchCommandesEnAttente();
      fetchHistorique();
      fetchLivraisonsEnCours();
    });

    socket.on('commande-mise-a-jour', (data) => {
      console.log('Commande mise à jour:', data);
      fetchLivraisonsEnCours();
      fetchHistorique();
    });

    socket.on('facture-generee', (data) => {
      console.log('Facture générée:', data);
      fetchLivraisonsEnCours();
      setMessage(data.message);
    });

    socket.on('facture-confirmee', (data) => {
      console.log('Facture confirmée:', data);
      fetchLivraisonsEnCours();
      setMessage(data.message);
    });

    return () => {
      socket.off('nouvelle-commande');
      socket.off('commande-validee');
      socket.off('commande-mise-a-jour');
      socket.off('facture-generee');
      socket.off('facture-confirmee');
    };
  }, []);

  const fetchCommandesEnAttente = () => {
    axios.get('http://localhost:5000/api/commandes-en-attente')
      .then(response => setCommandes(response.data))
      .catch(err => {
        console.error('Erreur récupération commandes:', err);
        setMessage('Erreur lors du chargement des commandes');
      });
  };

  const fetchLivraisonsEnCours = () => {
    axios.get('http://localhost:5000/api/livraisons-en-cours')
      .then(response => {
        console.log('Livraisons en cours:', response.data);
        setLivraisonsEnCours(response.data);
      })
      .catch(err => {
        console.error('Erreur récupération livraisons:', err);
        setMessage('Erreur lors du chargement des livraisons en cours');
      });
  };

  const fetchHistorique = () => {
    console.log('Tentative de récupération de l\'historique...');
    axios.get('http://localhost:5000/api/commandes/historique')
      .then(response => {
        console.log('Historique reçu:', response.data);
        setHistorique(response.data);
        setMessage('');
      })
      .catch(err => {
        console.error('Erreur détaillée récupération historique:', err);
        if (err.response) {
          console.error('Status:', err.response.status);
          console.error('Data:', err.response.data);
          setMessage(`Erreur ${err.response.status}: ${err.response.data.message || 'Route non trouvée'}`);
        } else if (err.request) {
          console.error('No response received:', err.request);
          setMessage('Serveur inaccessible - vérifie que le serveur est démarré');
        } else {
          console.error('Error:', err.message);
          setMessage('Erreur de configuration: ' + err.message);
        }
      });
  };

  const fetchLivreurs = () => {
    axios.get('http://localhost:5000/api/livreurs')
      .then(response => setLivreurs(response.data))
      .catch(err => console.error('Erreur récupération livreurs:', err));
  };

  const validerCommande = (id, emailLivreur) => {
    axios.put(`http://localhost:5000/api/commandes/${id}/valider`, { email_livreur: emailLivreur })
      .then(() => {
        setMessage('Commande validée avec succès');
        fetchCommandesEnAttente();
        fetchHistorique();
        fetchLivraisonsEnCours();
      })
      .catch(err => {
        console.error('Erreur validation:', err);
        setMessage(err.response?.data?.message || 'Erreur lors de la validation');
      });
  };

  const genererFacture = async (commandeId) => {
    try {
      const response = await axios.post(`http://localhost:5000/api/commandes/${commandeId}/generer-facture`);
      setFactures(prev => ({
        ...prev,
        [commandeId]: response.data.facture
      }));
      setMessage('Facture générée avec succès');
      
      socket.emit('notification-livreur', {
        message: `Facture générée pour la commande #${commandeId}`,
        commandeId: commandeId
      });
      
    } catch (err) {
      console.error('Erreur génération facture:', err);
      setMessage(err.response?.data?.message || 'Erreur lors de la génération de la facture');
    }
  };

  const confirmerFacture = async (commandeId) => {
    try {
      await axios.put(`http://localhost:5000/api/factures/${commandeId}/confirmer`);
      setMessage('Facture confirmée avec succès');
      
      setFactures(prev => ({
        ...prev,
        [commandeId]: {
          ...prev[commandeId],
          statut: 'Facture confirmée'
        }
      }));
      
    } catch (err) {
      console.error('Erreur confirmation facture:', err);
      setMessage(err.response?.data?.message || 'Erreur lors de la confirmation de la facture');
    }
  };

  const mettreEnPreparation = async (commandeId) => {
    try {
      // Appeler l'API pour générer la facture (ce qui mettra aussi le statut en "En préparation")
      const response = await axios.post(`http://localhost:5000/api/commandes/${commandeId}/generer-facture`);
      
      setFactures(prev => ({
        ...prev,
        [commandeId]: response.data.facture
      }));
      
      setMessage('Commande mise en préparation et facture générée');
      
      // Recharger les données
      fetchLivraisonsEnCours();
      fetchHistorique();
      
    } catch (err) {
      console.error('Erreur mise en préparation:', err);
      setMessage(err.response?.data?.message || 'Erreur lors de la mise en préparation');
    }
  };

  const imprimerFacture = (commandeId) => {
    const facture = factures[commandeId];
    if (!facture) return;
    
    const printWindow = window.open('', '_blank');
    printWindow.document.write(`
      <html>
        <head>
          <title>Facture Commande #${facture.id_commande}</title>
          <style>
            body { font-family: Arial, sans-serif; margin: 40px; }
            .header { text-align: center; margin-bottom: 30px; }
            .info { margin-bottom: 20px; }
            .table { width: 100%; border-collapse: collapse; margin: 20px 0; }
            .table th, .table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
            .table th { background-color: #f2f2f2; }
            .total { font-weight: bold; text-align: right; margin-top: 20px; }
            .footer { margin-top: 40px; text-align: center; font-size: 12px; }
          </style>
        </head>
        <body>
          <div class="header">
            <h1>Facture Café Mahatsara</h1>
            <p>Commande #${facture.id_commande}</p>
          </div>
          
          <div class="info">
            <p><strong>Date:</strong> ${new Date(facture.date_facture).toLocaleDateString('fr-FR')}</p>
            <p><strong>Client:</strong> ${facture.client.nom}</p>
            <p><strong>Adresse:</strong> ${facture.client.adresse}</p>
            <p><strong>Contact:</strong> ${facture.client.contact}</p>
          </div>
          
          <table class="table">
            <thead>
              <tr>
                <th>Produit</th>
                <th>Quantité</th>
                <th>Prix Unitaire</th>
                <th>Total</th>
              </tr>
            </thead>
            <tbody>
              ${facture.produits.map(produit => `
                <tr>
                  <td>${produit.type}</td>
                  <td>${produit.quantite}</td>
                  <td>${produit.prix_unitaire.toLocaleString('fr-FR')} Ar</td>
                  <td>${produit.prix_total.toLocaleString('fr-FR')} Ar</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
          
          <div class="total">
            <p>Total: ${facture.produits[0].prix_total.toLocaleString('fr-FR')} Ar</p>
          </div>
          
          <div class="footer">
            <p>Merci pour votre confiance ! Café Mahatsara</p>
          </div>
        </body>
      </html>
    `);
    printWindow.document.close();
    printWindow.print();
  };

  const getStatusBadageClass = (statut) => {
    switch(statut) {
      case 'Validée': return 'statut-validee';
      case 'En préparation': return 'statut-preparation';
      case 'En route pour livraison': return 'statut-en-route';
      case 'Livré': return 'statut-livre';
      case 'Facture confirmée': return 'statut-confirmee';
      default: return 'statut-default';
    }
  };

  return (
    <div className="admin-section">
      <h3>Gérer les Commandes</h3>
      {message && <p className="message">{message}</p>}
      
      <div className="tabs">
        <button 
          className={activeTab === 'en-attente' ? 'active' : ''}
          onClick={() => setActiveTab('en-attente')}
        >
          📋 En attente ({commandes.length})
        </button>
        <button 
          className={activeTab === 'en-cours' ? 'active' : ''}
          onClick={() => setActiveTab('en-cours')}
        >
          🚚 Livraisons en cours ({livraisonsEnCours.length})
        </button>
        <button 
          className={activeTab === 'historique' ? 'active' : ''}
          onClick={() => setActiveTab('historique')}
        >
          📊 Historique ({historique.length})
        </button>
      </div>

      {activeTab === 'en-attente' && (
        <div className="commandes-list">
          <h4>Commandes en attente de validation</h4>
          {commandes.length > 0 ? (
            <table>
              <thead>
                <tr>
                  <th>ID</th>
                  <th>Client</th>
                  <th>Produit</th>
                  <th>Quantité</th>
                  <th>Prix total</th>
                  <th>Date</th>
                  <th>Assigner Livreur</th>
                  <th>Action</th>
                </tr>
              </thead>
              <tbody>
                {commandes.map(cmd => (
                  <tr key={cmd.id}>
                    <td>{cmd.id}</td>
                    <td>{cmd.client_nom}</td>
                    <td>{cmd.type_produit}</td>
                    <td>{cmd.quantite}</td>
                    <td>{cmd.prix_total} Ar</td>
                    <td>{new Date(cmd.date_commande).toLocaleString('fr-FR')}</td>
                    <td>
                      <select onChange={(e) => {
                        const emailLivreur = e.target.value;
                        if (emailLivreur) validerCommande(cmd.id, emailLivreur);
                      }}>
                        <option value="">Sélectionner un livreur</option>
                        {livreurs.map(livreur => (
                          <option key={livreur.email} value={livreur.email}>{livreur.nom}</option>
                        ))}
                      </select>
                    </td>
                    <td>
                      <button onClick={() => validerCommande(cmd.id, '')}>Valider sans livreur</button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          ) : (
            <p>Aucune commande en attente</p>
          )}
        </div>
      )}

{activeTab === 'en-cours' && (
  <div className="livraisons-list">
    <h4>Livraisons en cours</h4>
    {livraisonsEnCours.length > 0 ? (
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Client</th>
            <th>Adresse</th>
            <th>Produit</th>
            <th>Quantité</th>
            <th>Livreur</th>
            <th>Statut</th>
            <th>Date commande</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          {livraisonsEnCours.map(livraison => (
            <tr key={livraison.id}>
              <td>{livraison.id}</td>
              <td>{livraison.client_nom}</td>
              <td>{livraison.client_adresse}</td>
              <td>{livraison.type_produit}</td>
              <td>{livraison.quantite}</td>
              <td>{livraison.livreur_nom || 'Non assigné'}</td>
              <td>
                <span className={`statut-badge ${getStatusBadageClass(livraison.statut)}`}>
                  {livraison.statut}
                </span>
              </td>
              <td>{new Date(livraison.date_commande).toLocaleString('fr-FR')}</td>
              <td>
                {/* BOUTON POUR METTRE EN PRÉPARATION */}
                {livraison.statut === 'Validée' && (
                  <button 
                    className="btn-preparation"
                    onClick={() => mettreEnPreparation(livraison.id)}
                  >
                    🛒 Mettre en préparation
                  </button>
                )}
                
                {/* BOUTONS FACTURE */}
                {livraison.statut === 'En préparation' && (
                  <div className="facture-actions">
                    <button 
                      className="btn-confirmer"
                      onClick={() => confirmerFacture(livraison.id)}
                    >
                      ✅ Confirmer Facture
                    </button>
                    <button 
                      className="btn-imprimer"
                      onClick={() => imprimerFacture(livraison.id)}
                    >
                      🖨️ Imprimer
                    </button>
                  </div>
                )}
                
                {livraison.statut === 'Facture confirmée' && (
                  <button 
                    className="btn-imprimer"
                    onClick={() => imprimerFacture(livraison.id)}
                  >
                    🖨️ Imprimer Facture
                  </button>
                )}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    ) : (
      <p>Aucune livraison en cours</p>
    )}
  </div>
)}

      {activeTab === 'historique' && (
        <div className="historique-list">
          <h4>Historique des Commandes</h4>
          {historique.length > 0 ? (
            <table>
              <thead>
                <tr>
                  <th>ID</th>
                  <th>Client</th>
                  <th>Quantité</th>
                  <th>Date</th>
                  <th>Prix Produit</th>
                  <th>Prix Total</th>
                  <th>Livreur</th>
                  <th>Statut</th>
                </tr>
              </thead>
              <tbody>
                {historique.map(cmd => (
                  <tr key={cmd.id}>
                    <td>{cmd.id}</td>
                    <td>{cmd.client_nom || 'Non spécifié'}</td>
                    <td>{cmd.quantite}</td>
                    <td>{new Date(cmd.date_commande).toLocaleString('fr-FR')}</td>
                    <td>{cmd.prix_total && cmd.quantite ? (cmd.prix_total / cmd.quantite) + ' Ar' : 'N/A'}</td>
                    <td>{cmd.prix_total || 'N/A'} Ar</td>
                    <td>{cmd.email_livreur || 'Non assigné'}</td>
                    <td>
                      <span className={`statut-badge ${getStatusBadageClass(cmd.statut)}`}>
                        {cmd.statut}
                      </span>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          ) : (
            <p>Aucun historique disponible</p>
          )}
        </div>
      )}
    </div>
  );
};

export default Commandes;


RO:
Ok mon pote, tu veux savoir les rôles (RO) possibles et la gestion des entités pour ton système avec ces tables : client, commande, livreur, message, produit, admin. Je vais te détailler clairement la logique de gestion et les relations possibles.

1️⃣ Les entités et leurs rôles possibles
Entité	Rôle / responsabilité
Admin	Gérer le système : ajouter/modifier/supprimer des produits, gérer les commandes, voir l’historique des livraisons, gérer les livreurs et éventuellement voir les messages.
Client	Passer une commande, voir le stock disponible, suivre l’état de sa commande, envoyer un message (réclamation ou question).
Livreur	Voir les commandes attribuées, signaler le statut (“en préparation”, “en cours de livraison”, “livré”), recevoir des notifications/messages.
Commande	Contient les produits commandés, l’état de la commande (en préparation, livrée…), le client qui a commandé, et le livreur qui doit la livrer.
Produit	Fournit les informations sur les articles disponibles (nom, prix, stock, etc.).
Message	Permet la communication entre client/livreur/admin (ex: réclamation, notification, suivi de commande).
2️⃣ Relations possibles (RO = Relations et opérations)

Client → Commande :

Un client peut passer plusieurs commandes.

Une commande appartient à un seul client.

Relation : 1..* commandes pour 1 client.

Commande → Produit :

Une commande peut contenir plusieurs produits.

Un produit peut apparaître dans plusieurs commandes.

Relation : Commande <--> Produit = N:N (nécessite une table intermédiaire commande_produit avec quantité).

Commande → Livreur :

Une commande est attribuée à un livreur.

Un livreur peut avoir plusieurs commandes.

Relation : 1..* commandes pour 1 livreur.

Message → Client / Livreur / Admin :

Un message peut être envoyé par n’importe quel rôle à un autre rôle.

Il faut stocker id_sender, role_sender, id_receiver, role_receiver.

Admin → Produit / Commande / Livreur :

L’admin peut créer, modifier, supprimer des produits.

L’admin peut valider ou annuler des commandes.

L’admin peut attribuer les commandes aux livreurs.

3️⃣ Exemple de règles de gestion possibles

Commande :

Un client peut annuler une commande si elle n’est pas encore en préparation.

Une commande passe par les états : en attente → en préparation → en livraison → livrée.

Livreur :

Peut confirmer qu’une commande est “en livraison” ou “livrée”.

Peut envoyer un message au client si problème avec la commande.

Message :

Utilisé pour communication client ↔ admin, client ↔ livreur, livreur ↔ admin.

Stock produit :

Diminue automatiquement lorsqu’une commande est validée.

L’admin peut recharger le stock.

Si tu veux, je peux te dessiner un schéma RO (diagramme relationnel / UML) avec toutes ces entités et leurs relations, ça sera plus clair et prêt à utiliser pour ton projet.

Veux‑tu que je fasse ça ?


Joyeux anniversaire à la meilleure maman du monde ! 
Merci d’être toujours là pour moi, pour ton amour et tes conseils. 
Je te souhaite beaucoup de bonheur, de santé et de joie. Je t’aime infiniment.💖🌹

RO: Proposition de relations avec cardinalités :

Client – Commande

Un client peut passer plusieurs commandes

Une commande appartient à un seul client
→ Relation : Client (1,n) – (1,1) Commande

Commande – Produit

Une commande peut contenir plusieurs produits

Un produit peut être présent dans plusieurs commandes
→ Relation : Commande (1,n) – (1,n) Produit
⚠ Ici on crée souvent une table d’association commande_produit.

Livreur – Commande

Un livreur peut livrer plusieurs commandes

Une commande est livrée par un seul livreur
→ Relation : Livreur (1,n) – (1,1) Commande

Client – Message

Un client peut envoyer plusieurs messages

Un message est envoyé par un seul client
→ Relation : Client (1,n) – (1,1) Message

Admin – Message

L’admin peut répondre à plusieurs messages

Un message peut être répondu par un seul admin
→ Relation : Admin (1,n) – (1,1) Message

chapitre 7 Chapitre 7 : Spécification des outils de réalisation
7.1. Le système de gestion de base de données (SGBD)

Un SGBD est un logiciel conçu pour établir des interactions avec une base de données. Il permet le contrôle, l’organisation et la manipulation des données stockées dans des tableaux. Le choix d’un SGBD repose sur plusieurs critères : accessibilité aux données, gestion multi-utilisateur, et capacités de manipulation des données (insertion, modification, suppression).

7.1.1. Définition d’une base de données

Une base de données est un ensemble structuré de données permettant leur stockage tout en minimisant la redondance. Ces données sont accessibles par différents programmes et utilisateurs, souvent via un réseau. L’ensemble des dispositifs qui permettent la mutualisation des données constitue ce qu’on appelle un système d’information.

7.1.2. Utilité d’une base de données

Consolidation des données : centralisation des informations pour éviter la duplication.

Accessibilité multi-utilisateur : plusieurs utilisateurs peuvent accéder aux données simultanément.

Local ou distribué :

Local : données accessibles sur une seule machine.

Distribué : données accessibles via un réseau sur plusieurs machines.

7.2. Caractéristiques des SGBD

L’architecture à trois niveaux (ANSI/PARC) sépare les données des processus. Un SGBD doit présenter les caractéristiques suivantes :

Indépendance physique : modifications du niveau physique sans affecter l’utilisateur.

Indépendance logique : modifications du niveau conceptuel sans impacter le stockage physique.

Rapidité d’accès : algorithmes efficaces pour fournir des réponses aux requêtes rapidement.

Administration centralisée : limitation des redondances et gestion efficace de l’espace mémoire.

Sécurisation des données : contrôle des droits d’accès selon les utilisateurs.

7.3. Points forts et faibles des SGBD

Points forts : fiabilité, sécurité, rapidité d’accès, gestion multi-utilisateurs, intégrité des données.

Points faibles : coût d’acquisition et de maintenance, complexité d’administration, dépendance à un logiciel spécifique.

7.4. Les langages et frameworks utilisés

PostgreSQL : SGBD relationnel utilisé pour gérer efficacement les données.

React et Angular : frameworks front-end pour créer des interfaces utilisateur dynamiques et réactives.

Laravel : framework PHP pour développer l’application côté serveur.

7.4.1. Historique et points forts de Laravel

Facilité de développement grâce à sa syntaxe claire.

Gestion des routes, modèles, et contrôleurs simplifiée.

Intégration native avec des bases de données comme PostgreSQL.

7.4.2. Comparaison avec d’autres frameworks PHP

CodeIgniter : plus léger, moins de fonctionnalités natives que Laravel.

Symfony : plus robuste mais complexe pour un petit projet.

7.4.3. Structure initiale d’un projet Laravel

App/ : contient les modèles, contrôleurs et middleware.

Database/ : contient les migrations et seeders.

Routes/ : fichier de configuration des routes (web.php, api.php).

7.5. Les APIs
7.5.1. Différence entre REST et SOAP

SOAP : protocole standardisé utilisant XML, plus lourd, plus sécurisé mais moins flexible.

REST : architecture légère utilisant HTTP et JSON, facile à consommer et à intégrer avec les frameworks modernes comme Angular et React.

7.5.2. Choix de REST API

REST a été choisi pour sa légèreté, sa compatibilité avec les applications web modernes et sa simplicité d’intégration avec Angular et React. ET 


Chapitre 8 : Mise en œuvre et implémentation
8.1. Introduction

Ce chapitre présente les étapes pratiques de réalisation du projet. Il décrit l’installation des outils, la configuration des environnements de développement, la création de la base de données, le développement des fonctionnalités et l’intégration des différents composants (frontend, backend, APIs).

8.2. Environnement de développement

Pour la mise en œuvre du projet, les environnements suivants ont été utilisés :

Composant	Outil / Framework	Version / Configuration
SGBD	PostgreSQL	14
Backend	Laravel	10
Frontend	Angular	15
Frontend alternatif	React	18
Serveur web	Apache	2.4
IDE	VS Code / PhpStorm	-
Gestion de versions	Git	-
8.2.1. Installation et configuration

PostgreSQL : création d’une base de données pour le projet, configuration des utilisateurs et des droits d’accès.

Laravel : installation via Composer, configuration du fichier .env pour la connexion à la base de données.

Angular / React : installation via Node.js et npm, création du projet et configuration des routes et composants principaux.

8.3. Conception de la base de données

La base de données a été conçue en respectant le modèle relationnel. Les principales tables sont :

Client : informations sur les clients (id, nom, email, téléphone).

Commande : informations sur les commandes (id, date, montant, id_client).

Produit : informations sur les produits (id, nom, prix, stock).

Livreur : informations sur les livreurs (id, nom, email, téléphone).

Message : pour la communication entre client et livreur/admin (id, contenu, id_client, id_livreur).

Des relations appropriées (clé primaire / clé étrangère) ont été établies pour assurer l’intégrité des données.

8.4. Développement Backend (Laravel)
8.4.1. Structure des fichiers

App/Models : modèles représentant les tables de la base de données.

App/Http/Controllers : logique métier pour gérer les requêtes et réponses.

Routes/api.php : définition des endpoints REST pour le frontend.

8.4.2. Fonctionnalités principales

Gestion des clients, produits, commandes et livreurs.

Authentification sécurisée (mot de passe hashé).

Gestion des stocks et validation automatique des commandes.

Envoi des notifications aux utilisateurs lors des changements d’état des commandes.

8.5. Développement Frontend (Angular / React)
8.5.1. Structure des composants

Pages principales : tableau de bord, liste des commandes, suivi des livraisons.

Composants réutilisables : boutons, modals, formulaires, graphiques.

Services : communication avec le backend via REST API.

8.5.2. Fonctionnalités principales

Affichage dynamique des données (clients, commandes, stock).

Interaction en temps réel via WebSocket pour notifications.

Interface utilisateur responsive et intuitive.

8.6. Intégration et tests

Tests unitaires : vérification des fonctions critiques du backend et du frontend.

Tests d’intégration : validation de la communication entre le frontend et le backend via API.

Tests fonctionnels : simulation des cas d’utilisation (ajout de commande, modification de stock, notifications).

8.7. Sécurisation et sauvegarde

Mise en place de droits d’accès selon les rôles.

Sauvegarde régulière de la base de données PostgreSQL.

Utilisation du protocole HTTPS pour sécuriser les échanges entre frontend et backend.
